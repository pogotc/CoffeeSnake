// Generated by CoffeeScript 1.4.0
(function() {
  var $, $canvas, applePos, appleTimeout, clearBackground, context, currentAppleType, drawApple, drawDeadScreen, drawSnake, dx, dy, endGame, gameBoardWidth, gameState, generateNewRandomPosition, gridPosToCanvasPos, gridSize, highScore, initGame, moveSnake, numColumns, numRows, positionApple, positionCollidesWithSnake, score, snake, snakePiecesLeftToAdd, tick, updateScore;

  $ = jQuery;

  $canvas = document.getElementById('snake-game');

  context = $canvas.getContext("2d");

  gridSize = 20;

  numColumns = 30;

  numRows = 25;

  snake = [];

  applePos = {
    x: 10,
    y: 10
  };

  currentAppleType = "green";

  dx = 1;

  dy = 0;

  appleTimeout = null;

  highScore = 0;

  score = 0;

  snakePiecesLeftToAdd = 0;

  gameState = "inprogress";

  $(document).keydown(function(evt) {
    if (gameState === "dead" && evt.keyCode === 32) {
      initGame();
      return;
    }
    if (evt.keyCode === 40 && dy === 0) {
      dy = 1;
      return dx = 0;
    } else if (evt.keyCode === 38 && dy === 0) {
      dy = -1;
      return dx = 0;
    } else if (evt.keyCode === 37 && dx === 0) {
      dx = -1;
      return dy = 0;
    } else if (evt.keyCode === 39 && dx === 0) {
      dx = 1;
      return dy = 0;
    }
  });

  initGame = function() {
    dx = 1;
    dy = 0;
    snake = [
      {
        x: 5,
        y: 5
      }, {
        x: 6,
        y: 5
      }, {
        x: 7,
        y: 5
      }
    ];
    positionApple(snake);
    gameState = "inprogress";
    score = 0;
    updateScore(0);
    return currentAppleType = "green";
  };

  gameBoardWidth = function() {
    return numColumns * gridSize;
  };

  clearBackground = function(ctx) {
    ctx.fillStyle = "#333333";
    return ctx.fillRect(0, 0, gameBoardWidth(), 500);
  };

  gridPosToCanvasPos = function(pos) {
    return pos * gridSize;
  };

  drawSnake = function(ctx, snake) {
    var pos, _i, _len;
    context.fillStyle = '#FFFFFF';
    for (_i = 0, _len = snake.length; _i < _len; _i++) {
      pos = snake[_i];
      context.fillRect(gridPosToCanvasPos(pos.x) + 1, gridPosToCanvasPos(pos.y) + 1, gridSize - 2, gridSize - 2);
    }
    return null;
  };

  generateNewRandomPosition = function() {
    var newPos;
    newPos = {
      x: Math.floor(Math.random() * numColumns),
      y: Math.floor(Math.random() * numRows)
    };
    return newPos;
  };

  positionApple = function(snake) {
    var pos;
    console.log("Positioning");
    pos = generateNewRandomPosition();
    while (positionCollidesWithSnake(pos, snake)) {
      pos = generateNewRandomPosition();
    }
    applePos = pos;
    if (Math.random() > 0.8) {
      console.log("Setting timeout");
      currentAppleType = "red";
      return appleTimeout = setTimeout(function() {
        return positionApple(snake);
      }, 7000);
    } else {
      return currentAppleType = "green";
    }
  };

  positionCollidesWithSnake = function(pos, snake) {
    var snakePos, _i, _len;
    for (_i = 0, _len = snake.length; _i < _len; _i++) {
      snakePos = snake[_i];
      if (pos.x === snakePos.x && pos.y === snakePos.y) {
        return true;
      }
    }
    return false;
  };

  updateScore = function(points) {
    score += points * snake.length;
    return $('#score').html(score);
  };

  moveSnake = function(snake) {
    var snakeHead, snakeIsDead;
    snakeHead = {
      x: snake[snake.length - 1].x + dx,
      y: snake[snake.length - 1].y + dy
    };
    snakeIsDead = positionCollidesWithSnake(snakeHead, snake);
    if (snakeHead.x < 0 || snakeHead.x >= numColumns) {
      snakeIsDead = true;
    } else if (snakeHead.y < 0 || snakeHead.y >= numRows) {
      snakeIsDead = true;
    } else {
      snake.push(snakeHead);
    }
    if (snakeHead.x === applePos.x && snakeHead.y === applePos.y) {
      if (currentAppleType === "green") {
        snakePiecesLeftToAdd = 2;
      } else if (currentAppleType === "red") {
        snakePiecesLeftToAdd = 5;
      }
      console.log("Clearing timeout");
      clearTimeout(appleTimeout);
      positionApple(snake);
      updateScore(25);
    } else if (snakeIsDead) {
      endGame();
    } else if (snakePiecesLeftToAdd === 0) {
      snake.shift();
    }
    if (snakePiecesLeftToAdd > 0) {
      snakePiecesLeftToAdd--;
    }
    return null;
  };

  endGame = function() {
    gameState = "dead";
    console.log(score, highScore);
    if (score > highScore) {
      highScore = score;
    }
    return $("#high-score").html(highScore);
  };

  drawApple = function(ctx) {
    if (currentAppleType === "green") {
      context.fillStyle = '#00AA00';
    } else if (currentAppleType = "red") {
      context.fillStyle = '#AA0000';
    }
    return context.fillRect(gridPosToCanvasPos(applePos.x) + 1, gridPosToCanvasPos(applePos.y) + 1, gridSize - 2, gridSize - 2);
  };

  drawDeadScreen = function(ctx) {
    var deadMessage, restartMessage;
    ctx.fillStyle = '#AA0000';
    ctx.font = "36px Helvetica";
    deadMessage = "You killed the snake!";
    ctx.fillText(deadMessage, gameBoardWidth() / 2 - ctx.measureText(deadMessage).width / 2, 150);
    ctx.font = "18px Helvetica";
    restartMessage = "Press space to restart";
    return ctx.fillText(restartMessage, gameBoardWidth() / 2 - ctx.measureText(restartMessage).width / 2, 180);
  };

  tick = function() {
    clearBackground(context);
    drawApple();
    drawSnake(context, snake);
    if (gameState === "inprogress") {
      return moveSnake(snake);
    } else if (gameState === "dead") {
      return drawDeadScreen(context);
    }
  };

  initGame();

  setInterval(function() {
    return tick();
  }, 150);

}).call(this);
